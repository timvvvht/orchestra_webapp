/* Autogenerated rewrite by AI ‚Äì Orchestra-compatible ACSStreamingService
   Maintains original public API & types.
*/
import { eventBus } from '../eventBus';

import type { SSEEvent, SSEEventHandler, ACSClientConfig, RequestOptions } from '../shared/types';
import { SSE_EVENT_TYPES } from '../shared/types';

// ------------------------------------------------------------
// TYPE GUARDS + HELPERS (private)
// ------------------------------------------------------------

// ------------------------------------------------------------
// GLOBAL DEBUG UTILITY & TELEMETRY
// ------------------------------------------------------------
// Turn on verbose streaming logs at runtime via:
//    window.__ORCHESTRA_DEBUG = true
// ------------------------------------------------------------
const GLOBAL_DEBUG_FLAG: boolean = typeof window !== 'undefined' && !!(window as any).__ORCHESTRA_DEBUG;
function dbg(...args: any[]) {
    if (GLOBAL_DEBUG_FLAG) {
        // eslint-disable-next-line no-console
        console.log('[ACSStreaming]', ...args);
    }
}

// Defensive telemetry - global counter for lost events
if (typeof window !== 'undefined') {
    (window as any).__lostEvents = 0;
}

interface OrchestraAgentEvent {
    v: number;
    type: 'agent_event';
    payload: {
        event_id: string;
        session_id: string;
        event_type: string;
        timestamp: number;
        data: Record<string, any>;
        message_id?: string;
        is_replay?: boolean;
    };
}

interface OrchestraSystemEvent {
    type: 'connected' | 'heartbeat' | 'reconnection';
    session_id?: string;
    timestamp?: number;
    payload?: any;
}

type OrchestraEvent = OrchestraAgentEvent | OrchestraSystemEvent | any;

// ------------------------------------------------------------
// MAIN CLASS
// ------------------------------------------------------------
export class ACSStreamingService {
    private eventSource: EventSource | null = null;
    private config: ACSClientConfig;
    private firehoseService?: any; // Will be injected by OrchestACSClient

    private reconnectAttempts = 0;
    private maxReconnectAttempts = 5;
    private reconnectDelay = 1000;
    private isConnecting = false; // ‚¨Ö we'll keep it but respect it
    /** millis of last successful onopen */
    private lastOpenAt = 0;
    /** current session ID for this connection */
    private currentSessionId: string | undefined;

    private eventHandlers = new Map<string, Set<SSEEventHandler>>();
    private globalHandlers = new Set<SSEEventHandler>();
    private connectionHandlers = new Set<(connected: boolean) => void>();

    constructor(config: ACSClientConfig) {
        this.config = config;
    }

    /** Set the firehose service for user-specific connections */
    setFirehoseService(firehoseService: any): void {
        this.firehoseService = firehoseService;
    }

    /** true if an ES is OPEN or CONNECTING for THIS session id */
    private readyOrPending(sessionId: string): boolean {
        if (!this.eventSource) return false;
        if (this.isConnecting) return true; // CONNECTING for *some* sid
        const open = this.eventSource.readyState === EventSource.OPEN;
        const pending = this.eventSource.readyState === EventSource.CONNECTING;
        return (open || pending) && this.currentSessionId === sessionId;
    }

    // --------------------------------------------------------
    // PUBLIC API (unchanged signatures)
    // --------------------------------------------------------
    async connect(sessionId: string, options?: { autoReconnect?: boolean }): Promise<void> {
        console.log('üîå [ACSStreaming] üîó Attempting to connect:', {
            sessionId,
            autoReconnect: options?.autoReconnect
        });

        /* ‚ë† If we're already open OR connecting for the same session, NO-OP  */
        if (this.readyOrPending(sessionId)) {
            console.log('‚è≠Ô∏è [ACSStreaming] üîó Already connected or connecting for session:', sessionId);
            return;
        }

        /* ‚ë° If another sid is open, close AFTER the new one succeeds         */
        const previousES = this.eventSource;
        if (previousES) {
            console.log('üîÑ [ACSStreaming] üîó Closing previous connection for new session:', sessionId);
        }

        this.isConnecting = true;

        const { autoReconnect = true } = options || {};
        const url = this.buildSSEUrl(sessionId);

        console.log('üåê [ACSStreaming] üîó Creating EventSource connection:', {
            sessionId,
            url: url.substring(0, 100) + '...',
            autoReconnect
        });

        if (this.config.debug) {
            console.log('[ACSStreaming] Connecting to SSE:', url);
        }

        const es = new EventSource(url);
        this.eventSource = es;
        this.currentSessionId = sessionId;

        /** onopen */
        es.onopen = () => {
            console.log('üü¢ [ACSStreaming] üîó EventSource opened successfully!', {
                sessionId,
                readyState: es.readyState,
                url: url.substring(0, 100) + '...'
            });
            this.isConnecting = false;
            this.lastOpenAt = Date.now();
            /* dispose previous only now (prevents gap) */
            previousES?.close?.();
            this.notifyConnectionHandlers(true);
        };

        /** onerror ‚Äì schedule reconnect with capped back-off */
        es.onerror = () => {
            console.log('üî¥ [ACSStreaming] üí• EventSource error occurred!', {
                sessionId,
                readyState: es.readyState,
                reconnectAttempts: this.reconnectAttempts
            });
            this.notifyConnectionHandlers(false);
            if (options?.autoReconnect !== false) this.scheduleReconnect(sessionId, options);
        };

        /** onmessage */
        es.onmessage = e => {
            console.log('üì® [ACSStreaming] üì• EventSource message received:', {
                sessionId,
                dataLength: e.data?.length,
                lastEventId: e.lastEventId
            });
            this.handleOrchestraEvent(e);
        };

        /* give caller a promise that resolves once OPEN, rejects on timeout */
        return new Promise<void>((res, rej) => {
            const timeoutId = window.setTimeout(() => {
                if (es.readyState !== EventSource.OPEN) {
                    console.log('‚è∞ [ACSStreaming] üîó Connection timeout after 10s:', {
                        sessionId,
                        readyState: es.readyState
                    });
                    try {
                        es.close();
                    } catch (_) {}
                    rej(new Error('SSE onopen timeout'));
                }
            }, 10_000);

            /*  Important:  DO NOT overwrite existing handlers ‚Äì just hook once   */
            const openListener = () => {
                clearTimeout(timeoutId);
                res();
                es.removeEventListener('open', openListener);
                es.removeEventListener('error', errorListener);
            };

            const errorListener = (ev: Event) => {
                clearTimeout(timeoutId);
                rej(ev instanceof Error ? ev : new Error('EventSource error'));
                es.removeEventListener('open', openListener);
                es.removeEventListener('error', errorListener);
            };

            es.addEventListener('open', openListener);
            es.addEventListener('error', errorListener);
        });
    }

    async disconnect(): Promise<void> {
        console.log('üîå [ACSStreaming] üîå Disconnecting streaming...', {
            hasEventSource: !!this.eventSource,
            currentSessionId: this.currentSessionId,
            isConnecting: this.isConnecting
        });

        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
            console.log('‚úÖ [ACSStreaming] üîå EventSource closed successfully');
        }
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.notifyConnectionHandlers(false);
        console.log('‚úÖ [ACSStreaming] üîå Disconnection complete');
    }

    /** Connect to user-specific SSE endpoint with JWT authentication (for local tool events) */
    connectPrivate(userId: string, jwt: string): void {
        console.log('üîå [ACSStreaming] üîó Connecting to user-specific SSE endpoint:', {
            userId,
            hasJwt: !!jwt,
            hasFirehose: !!this.firehoseService,
            hasConnectPrivate: !!this.firehoseService?.connectPrivate
        });

        // üö® CRITICAL: Throw errors instead of silent warnings
        if (!this.firehoseService) {
            const error = new Error('üö® Firehose service not available - cannot establish user-specific connection for local tool events');
            console.error('‚ùå [ACSStreaming] CRITICAL ERROR:', error.message);
            throw error;
        }
        
        if (!this.firehoseService.connectPrivate) {
            const error = new Error('üö® Firehose service missing connectPrivate method - local tool routing will fail');
            console.error('‚ùå [ACSStreaming] CRITICAL ERROR:', error.message);
            throw error;
        }
        
        if (!userId) {
            const error = new Error('üö® User ID required for user-specific connection - local tool routing will fail');
            console.error('‚ùå [ACSStreaming] CRITICAL ERROR:', error.message);
            throw error;
        }
        
        if (!jwt) {
            const error = new Error('üö® JWT token required for user-specific connection - local tool routing will fail');
            console.error('‚ùå [ACSStreaming] CRITICAL ERROR:', error.message);
            throw error;
        }

        try {
            this.firehoseService.connectPrivate(userId, jwt);
            console.log('‚úÖ [ACSStreaming] üîó User-specific connection delegated to firehose service');
            
            // üö® CRITICAL: Verify connection was actually established
            setTimeout(() => {
                const isConnected = this.firehoseService.es?.readyState === EventSource.OPEN;
                const isUserConnection = this.firehoseService.connectionType === 'user';
                
                if (!isConnected || !isUserConnection) {
                    console.error('üö® [ACSStreaming] User connection verification FAILED:', {
                        isConnected,
                        isUserConnection,
                        connectionType: this.firehoseService.connectionType,
                        readyState: this.firehoseService.es?.readyState,
                        url: this.firehoseService.es?.url
                    });
                } else {
                    console.log('‚úÖ [ACSStreaming] User connection verified successfully:', {
                        userId,
                        connectionType: this.firehoseService.connectionType,
                        url: this.firehoseService.es?.url
                    });
                }
            }, 1000); // Check after 1 second
            
        } catch (error) {
            console.error('‚ùå [ACSStreaming] Failed to establish user-specific connection:', error);
            throw error;
        }
    }

    isConnected(): boolean {
        return this.eventSource?.readyState === EventSource.OPEN;
    }

    // subscription helpers (unchanged)
    onEvent(handler: SSEEventHandler): () => void {
        this.globalHandlers.add(handler);
        return () => this.globalHandlers.delete(handler);
    }
    onEventType(eventType: string, handler: SSEEventHandler): () => void {
        if (!this.eventHandlers.has(eventType)) this.eventHandlers.set(eventType, new Set());
        this.eventHandlers.get(eventType)!.add(handler);
        return () => {
            const set = this.eventHandlers.get(eventType);
            if (set) {
                set.delete(handler);
                if (set.size === 0) this.eventHandlers.delete(eventType);
            }
        };
    }
    onConnectionChange(handler: (connected: boolean) => void): () => void {
        this.connectionHandlers.add(handler);
        return () => this.connectionHandlers.delete(handler);
    }

    // Convenience wrappers (retain original names)
    onChunk(h: SSEEventHandler) {
        return this.onEventType(SSE_EVENT_TYPES.CHUNK, h);
    }
    onToken(h: SSEEventHandler) {
        return this.onEventType(SSE_EVENT_TYPES.TOKEN, h);
    }
    onToolCall(h: SSEEventHandler) {
        return this.onEventType(SSE_EVENT_TYPES.TOOL_CALL, h);
    }
    onToolResult(h: SSEEventHandler) {
        return this.onEventType(SSE_EVENT_TYPES.TOOL_RESULT, h);
    }
    onDone(h: SSEEventHandler) {
        return this.onEventType(SSE_EVENT_TYPES.DONE, h);
    }
    onError(h: SSEEventHandler) {
        return this.onEventType(SSE_EVENT_TYPES.ERROR, h);
    }
    onStatus(h: SSEEventHandler) {
        return this.onEventType(SSE_EVENT_TYPES.STATUS, h);
    }

    // Health / stats / test endpoints (updated to Orchestra paths)
    async testConnection(sessionId: string, opts?: RequestOptions) {
        const url = `${this.config.sseUrl}/api/broadcast/${encodeURIComponent(sessionId)}`;
        await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ event_type: 'test', data: { ping: Date.now() } }),
            signal: opts?.signal
        }).then(r => {
            if (!r.ok) throw new Error(`Test failed ${r.status}`);
        });
    }
    async getHealth(opts?: RequestOptions) {
        const r = await fetch(`${this.config.sseUrl}/health`, { signal: opts?.signal });
        if (!r.ok) throw new Error('Health check failed');
        return r.json();
    }
    async getStats(opts?: RequestOptions) {
        const r = await fetch(`${this.config.sseUrl}/api/stats`, { signal: opts?.signal });
        if (!r.ok) throw new Error('Stats failed');
        return r.json();
    }

    // --------------------------------------------------------
    // INTERNAL IMPLEMENTATION
    // --------------------------------------------------------
    private buildSSEUrl(sessionId: string): string {
        return `${this.config.sseUrl.replace(/\/$/, '')}/sse/${encodeURIComponent(sessionId)}`;
    }

    /** Core transformation from Orchestra event ‚Üí SSEEvent */
    private handleOrchestraEvent(evt: MessageEvent) {
        console.log('üì® [ACSStreaming] üì• Raw SSE message received:', {
            data: evt.data,
            dataLength: evt.data?.length,
            origin: evt.origin,
            lastEventId: evt.lastEventId
        });

        let raw: OrchestraEvent;
        try {
            raw = JSON.parse(evt.data);
            console.log('‚úÖ [ACSStreaming] üì• JSON parsed successfully:', {
                type: raw.type,
                hasPayload: !!raw.payload,
                timestamp: raw.payload?.timestamp
            });
        } catch (parseError) {
            console.log('‚ö†Ô∏è [ACSStreaming] üì• JSON parse failed, treating as text:', {
                error: parseError,
                data: evt.data
            });
            raw = { text: evt.data };
        }

        let transformed: SSEEvent | null = null;

        // 1. Agent events - Unwrap middleware for unified event structure
        if (raw && raw.type === 'agent_event' && raw.payload) {
            const p = raw.payload;
            console.log('ü§ñ [ACSStreaming] üéØ Processing agent event:', {
                eventType: p.event_type,
                sessionId: p.session_id,
                messageId: p.message_id,
                eventId: p.event_id,
                timestamp: p.timestamp
            });

            // Unwrap agent_event payload into direct event structure
            transformed = {
                type: p.event_type,
                sessionId: p.session_id ?? p.sessionId ?? raw.sessionId,
                event_id: p.event_id,
                messageId: p.message_id ?? p.messageId,
                delta: p.delta ?? this.extractDelta(p),
                toolCall: p.tool_call ?? p.toolCall ?? this.extractToolCall(p),
                result: p.tool_result ?? p.result ?? this.extractResult(p),
                error: p.error ?? this.extractError(p),
                data: p.data,
                seq: undefined
            };

            console.log('‚úÖ [ACSStreaming] üéØ Agent event transformed:', {
                type: transformed.type,
                hasDelta: !!transformed.delta,
                hasToolCall: !!transformed.toolCall,
                hasResult: !!transformed.result,
                hasError: !!transformed.error
            });
        }
        // 2. System events
        else if (raw.type === 'connected') {
            console.log('üü¢ [ACSStreaming] üîó Processing connected event:', {
                sessionId: raw.session_id
            });
            transformed = { type: SSE_EVENT_TYPES.CONNECTED, sessionId: raw.session_id, data: raw } as SSEEvent;
        } else if (raw.type === 'heartbeat') {
            console.log('üíì [ACSStreaming] üíì Processing heartbeat event');
            transformed = { type: 'heartbeat', sessionId: '', data: raw } as SSEEvent;
        } else if (raw.type === 'reconnection') {
            console.log('üîÑ [ACSStreaming] üîÑ Processing reconnection event:', {
                sessionId: raw.payload?.session_id
            });
            transformed = { type: 'reconnection', sessionId: raw.payload?.session_id || '', data: raw.payload } as SSEEvent;
        }
        // 3. Fallback text
        else {
            console.log('üìù [ACSStreaming] üìù Processing fallback text event:', {
                hasText: !!raw.text,
                textLength: raw.text?.length
            });
            transformed = { type: 'message', sessionId: '', delta: typeof raw.text === 'string' ? raw.text : undefined, data: raw } as SSEEvent;
        }

        // Defensive telemetry - detect lost events
        if (transformed && raw && raw.type === 'agent_event' && raw.payload) {
            const p = raw.payload;
            const now = Date.now();

            // Check for timestamp skew >5s (normalize server timestamp to milliseconds)
            const serverMs = p.timestamp < 1e12 ? p.timestamp * 1000 : p.timestamp;
            if (Math.abs(Date.now() - serverMs) > 5_000) {
                if (typeof window !== 'undefined') {
                    (window as any).__lostEvents++;
                }
                console.warn('‚ö†Ô∏è [ACSStreaming] ‚è∞ Timestamp skew detected:', {
                    serverTime: p.timestamp,
                    serverTimeMs: serverMs,
                    clientTime: now,
                    skew: Math.abs(now - serverMs),
                    eventType: p.event_type
                });
            }

            // Note: Sequence gap detection would require maintaining sequence state
            // This is a minimal implementation focusing on timestamp skew
        }

        // Dispatch to handlers
        if (transformed) {
            console.log('üì§ [ACSStreaming] üì§ Dispatching event to handlers:', {
                type: transformed.type,
                sessionId: transformed.sessionId,
                globalHandlers: this.globalHandlers.size,
                typeHandlers: this.eventHandlers.get(transformed.type)?.size || 0
            });

            if (this.config.debug) console.debug('[ACSStreaming] event ‚ûú', transformed);
            // üîÑ NEW BUS DISPATCH
            // emit on global event bus (no await needed)
            eventBus.emit('sse', transformed);

            // Legacy direct handlers (will be removed after migration)
            this.globalHandlers.forEach(h => safeCall(h, transformed!));
            const typeSet = this.eventHandlers.get(transformed.type);
            if (typeSet) typeSet.forEach(h => safeCall(h, transformed!));

            console.log('‚úÖ [ACSStreaming] üì§ Event dispatched successfully');
        } else {
            console.log('‚ùå [ACSStreaming] üì§ Failed to transform event:', {
                rawType: raw.type,
                hasPayload: !!raw.payload
            });
        }
    }

    private extractDelta(p: any) {
        if (p.event_type === 'chunk' || p.event_type === 'token') {
            return p.data?.text || p.data?.content || p.data?.delta;
        }
    }
    private extractToolCall(p: any) {
        if (p.event_type === 'tool_call') {
            return {
                id: p.data.call_id || p.event_id,
                name: p.data.tool_name || p.data.tool,
                arguments: p.data.tool_input || p.data.input || p.data
            };
        }
    }
    private extractResult(p: any) {
        if (p.event_type === 'tool_result') {
            return {
                call_id: p.data.call_id,
                tool_name: p.data.tool_name || p.data.tool,
                result: p.data.result || p.data.output,
                success: p.data.success
            };
        }
    }
    private extractError(p: any) {
        if (p.event_type === 'error') {
            return p.data.message || p.data.error || JSON.stringify(p.data);
        }
    }

    // ---------------- utility ----------------

    /* unchanged scheduleReconnect(), but cap at 30 s and add jitter */
    private scheduleReconnect(sessionId: string, opts?: any) {
        this.reconnectAttempts += 1;
        if (this.reconnectAttempts > this.maxReconnectAttempts) return;
        const backoff = Math.min(2 ** this.reconnectAttempts * 500, 30_000);
        setTimeout(() => {
            this.connect(sessionId, opts).catch(console.error);
        }, backoff + Math.random() * 400);
    }

    private notifyConnectionHandlers(connected: boolean) {
        console.log('üì¢ [ACSStreaming] üì¢ Notifying connection handlers:', {
            connected,
            handlerCount: this.connectionHandlers.size
        });
        this.connectionHandlers.forEach(h => safeCall(h, connected));
        console.log('‚úÖ [ACSStreaming] üì¢ Connection handlers notified');
    }

    // --------------------------------------------------------
    // CLEANUP METHODS
    // --------------------------------------------------------
    
    /** Close both session and user connections */
    public close() {
        console.log('üîå [ACSStreaming] üßπ Closing all connections...');
        
        // Close current session EventSource if open
        if (this.eventSource) {
            console.log('üîå [ACSStreaming] üßπ Closing session EventSource');
            this.eventSource.close();
            this.eventSource = null;
            this.currentSessionId = undefined;
            this.isConnecting = false;
        }
        
        // Tell firehoseService to close its user-pipe (safe no-op if not open)
        if (this.firehoseService?.disconnectUser) {
            console.log('üîå [ACSStreaming] üßπ Disconnecting user pipe via firehose service');
            this.firehoseService.disconnectUser();
        }
        
        console.log('‚úÖ [ACSStreaming] üßπ All connections closed');
    }

    /** Close only the session stream (keep user-pipe open) */
    public disconnectSession() {
        console.log('üîå [ACSStreaming] üßπ Disconnecting session stream only...');
        
        if (this.eventSource) {
            console.log('üîå [ACSStreaming] üßπ Closing session EventSource');
            this.eventSource.close();
            this.eventSource = null;
            this.currentSessionId = undefined;
            this.isConnecting = false;
            this.notifyConnectionHandlers(false);
        } else {
            console.log('‚ÑπÔ∏è [ACSStreaming] üßπ No session EventSource to close');
        }
        
        console.log('‚úÖ [ACSStreaming] üßπ Session disconnected (user pipe remains open)');
    }
}

// -------------------------------------------
// Helper: safe handler invocation
function safeCall(fn: Function, ...args: any[]) {
    try {
        fn(...args);
    } catch (e) {
        console.error('[ACSStreaming] handler error', e);
    }
}

export default ACSStreamingService;