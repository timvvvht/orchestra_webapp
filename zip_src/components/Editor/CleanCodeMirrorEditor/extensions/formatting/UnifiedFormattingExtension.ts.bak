/**
 * UnifiedFormattingExtension for handling all basic text formatting
 *
 * This extension replaces the old unified formatting system with a new implementation
 * that uses the extension architecture and properly integrates with the decoration manager.
 */

import { EditorView, Decoration, WidgetType } from '@codemirror/view';
import { BaseDecorationExtension } from '../../core/BaseDecorationExtension';
import { ExtensionPriority } from '../../core/types';
import { SortableDecoration } from '../../core/DecorationManager';
import { isOnActiveLine, getActiveLine, normalizeLanguageName } from '../../core/utils';
import { FormattingType, FormattingRange, CodeBlock } from './types';

/**
 * Widget for language indicator in code blocks
 */
class LanguageIndicatorWidget extends WidgetType {
    constructor(readonly language: string) {
        super();
    }

    eq(other: LanguageIndicatorWidget): boolean {
        return other.language === this.language;
    }

    toDOM(): HTMLElement {
        const indicator = document.createElement('span');
        indicator.className = 'code-block-language';
        indicator.textContent = this.language || 'text';
        return indicator;
    }
}

/**
 * Widget for copy button in code blocks
 */
class CopyButtonWidget extends WidgetType {
    constructor(readonly codeContent: string) {
        super();
    }

    eq(other: CopyButtonWidget): boolean {
        return other.codeContent === this.codeContent;
    }

    toDOM(): HTMLElement {
        const button = document.createElement('button');
        button.className = 'code-block-copy-button';
        button.innerHTML =
            '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        button.title = 'Copy code';

        // Add click event listener to copy the code
        button.addEventListener('click', e => {
            e.preventDefault();
            e.stopPropagation();

            // Copy the code to clipboard
            navigator.clipboard.writeText(this.codeContent.trim()).then(() => {
                // Visual feedback
                button.classList.add('copied');
                button.innerHTML =
                    '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';

                // Reset after 1.5 seconds
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.innerHTML =
                        '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                }, 1500);
            });
        });

        return button;
    }
}

/**
 * Extension for unified formatting
 */
export class UnifiedFormattingExtension extends BaseDecorationExtension {
    private codeBlocks: CodeBlock[] = [];

    /**
     * Create a new UnifiedFormattingExtension
     */
    constructor() {
        super({
            id: 'unified-formatting',
            name: 'Unified Formatting',
            priority: ExtensionPriority.High,
            enabled: true
        });
    }

    /**
     * Create decorations for unified formatting
     * @param view The CodeMirror editor view
     * @returns An array of sortable decorations
     */
    createDecorations(view: EditorView): SortableDecoration[] {
        const { state } = view;
        const { doc } = state;
        const decorations: SortableDecoration[] = [];

        // Detect code blocks first
        this.codeBlocks = this.detectCodeBlocks(view);

        // Process each visible range
        for (const { from, to } of view.visibleRanges) {
            let pos = from;

            while (pos <= to) {
                // Get the line at the current position
                const line = doc.lineAt(pos);
                const lineText = line.text;
                const isActive = isOnActiveLine(view, line.from);

                // Skip formatting detection for lines within code blocks
                // except for the code fence lines themselves
                const inCodeBlock = this.isLineInCodeBlock(line.number);
                const isCodeFenceLine = /^\s*```([a-zA-Z0-9_+#-]*)\s*$/.test(lineText);

                if (!inCodeBlock || isCodeFenceLine) {
                    // Detect headers (# to ######)
                    this.detectHeaders(line, decorations, isActive);

                    // Detect code fences (```)
                    this.detectCodeFences(line, decorations, isActive);

                    // Detect list markers
                    this.detectListMarkers(line, decorations, isActive);

                    // Detect inline formatting (bold, italic, etc.)
                    this.detectInlineFormatting(line, decorations, isActive);

                    // Detect links and images
                    this.detectLinksAndImages(line, decorations, isActive);

                    // Detect blockquotes
                    this.detectBlockquotes(line, decorations, isActive);

                    // Detect horizontal rules
                    this.detectHorizontalRules(line, decorations, isActive);
                }

                // Move to the next line
                pos = line.to + 1;
            }
        }

        // Add decorations for code blocks
        this.addCodeBlockDecorations(view, decorations);

        return decorations;
    }

    /**
     * Check if a line is part of a code block
     * @param lineNumber The line number to check
     * @returns True if the line is part of a code block, false otherwise
     */
    private isLineInCodeBlock(lineNumber: number): boolean {
        return this.codeBlocks.some(block => lineNumber >= block.startLine && lineNumber <= block.endLine);
    }

    /**
     * Detect all code blocks in the document
     * @param view The CodeMirror editor view
     * @returns An array of code blocks
     */
    private detectCodeBlocks(view: EditorView): CodeBlock[] {
        const { state } = view;
        const { doc } = state;
        const codeBlocks: CodeBlock[] = [];

        let inCodeBlock = false;
        let codeBlockStart = -1;
        let codeBlockStartPos = -1;
        let codeBlockLanguage = '';
        let codeBlockContent = '';

        // Process each line in the document
        for (let i = 1; i <= doc.lines; i++) {
            const line = doc.line(i);
            const lineText = line.text;

            // Check for code fence markers
            const isCodeFence = /^\s*```([a-zA-Z0-9_+#-]*)\s*$/.test(lineText);

            if (isCodeFence && !inCodeBlock) {
                // Start of code block
                inCodeBlock = true;
                codeBlockStart = i;
                codeBlockStartPos = line.from;

                // Extract language if specified
                const match = lineText.match(/^\s*```([a-zA-Z0-9_+#-]*)\s*$/);
                codeBlockLanguage = match && match[1] ? match[1].trim() : '';

                // Reset code block content
                codeBlockContent = '';
            } else if (isCodeFence && inCodeBlock) {
                // End of code block
                inCodeBlock = false;

                // Add the code block to our list
                codeBlocks.push({
                    startLine: codeBlockStart,
                    endLine: i,
                    startPos: codeBlockStartPos,
                    endPos: line.to,
                    language: codeBlockLanguage,
                    content: codeBlockContent
                });

                // Reset tracking variables
                codeBlockStart = -1;
                codeBlockStartPos = -1;
                codeBlockLanguage = '';
                codeBlockContent = '';
            } else if (inCodeBlock) {
                // Inside code block content
                codeBlockContent += lineText + '\n';
            }
        }

        // Handle any unclosed code blocks by closing them at the end of the document
        if (inCodeBlock && codeBlockStart > 0) {
            codeBlocks.push({
                startLine: codeBlockStart,
                endLine: doc.lines,
                startPos: codeBlockStartPos,
                endPos: doc.line(doc.lines).to,
                language: codeBlockLanguage,
                content: codeBlockContent
            });
        }

        return codeBlocks;
    }

    /**
     * Add decorations for code blocks
     * @param view The CodeMirror editor view
     * @param decorations The array of decorations to add to
     */
    private addCodeBlockDecorations(view: EditorView, decorations: SortableDecoration[]): void {
        const { state } = view;
        const activeLine = getActiveLine(view);
        
        console.log(`[UnifiedFormattingExtension] Adding decorations for ${this.codeBlocks.length} code blocks`);

        // Process code blocks
        for (const block of this.codeBlocks) {
            console.log(`[UnifiedFormattingExtension] Processing code block: lines ${block.startLine}-${block.endLine}, language=${block.language || 'none'}`);
            
            try {
                // Add line decorations for code blocks
                for (let i = block.startLine; i <= block.endLine; i++) {
                    const line = state.doc.line(i);
                    const isActiveLine = i === activeLine;

                    if (i === block.startLine) {
                        // Start of code block - add line decoration first
                        decorations.push({
                            from: line.from,
                            to: line.from,
                            decoration: Decoration.line({
                                class: `cm-code-block-start${block.language ? ` language-${block.language}` : ''}${isActiveLine ? ' cm-activeLine' : ''}`
                            }),
                            priority: 50,
                            source: this.config.id
                        });

                        // Add mark decoration for the code fence itself
                        const fenceMatch = line.text.match(/^(\s*```([a-zA-Z0-9_+#-]*)\s*)$/);
                        if (fenceMatch) {
                            const fullMatch = fenceMatch[1];
                            decorations.push({
                                from: line.from,
                                to: line.from + fullMatch.length,
                                decoration: Decoration.mark({
                                    class: 'cm-formatting cm-formatting-code-block-start',
                                    attributes: { 'data-formatting-type': 'code-fence-start' }
                                }),
                                priority: 55,
                                source: this.config.id
                            });
                        }
                        
                        // Add language indicator if a language is specified
                        if (block.language) {
                            decorations.push({
                                from: line.from,
                                to: line.from,
                                decoration: Decoration.widget({
                                    widget: new LanguageIndicatorWidget(block.language),
                                    side: 1
                                }),
                                priority: 60,
                                source: this.config.id
                            });
                        }

                        // Add copy button
                        decorations.push({
                            from: line.from,
                            to: line.from,
                            decoration: Decoration.widget({
                                widget: new CopyButtonWidget(block.content),
                                side: 2
                            }),
                            priority: 70,
                            source: this.config.id
                        });
                    } else if (i === block.endLine) {
                        // End of code block - add line decoration first
                        decorations.push({
                            from: line.from,
                            to: line.from,
                            decoration: Decoration.line({
                                class: `cm-code-block-end${isActiveLine ? ' cm-activeLine' : ''}`
                            }),
                            priority: 50,
                            source: this.config.id
                        });
                        
                        // Add mark decoration for the code fence itself
                        const fenceMatch = line.text.match(/^(\s*```\s*)$/);
                        if (fenceMatch) {
                            const fullMatch = fenceMatch[1];
                            decorations.push({
                                from: line.from,
                                to: line.from + fullMatch.length,
                                decoration: Decoration.mark({
                                    class: 'cm-formatting cm-formatting-code-block-end',
                                    attributes: { 'data-formatting-type': 'code-fence-end' }
                                }),
                                priority: 55,
                                source: this.config.id
                            });
                        }
                    } else {
                        // Inside code block content - just add line decoration
                        decorations.push({
                            from: line.from,
                            to: line.from,
                            decoration: Decoration.line({
                                class: `cm-code-block-content${block.language ? ` language-${block.language}` : ''}${isActiveLine ? ' cm-activeLine' : ''}`
                            }),
                            priority: 50,
                            source: this.config.id
                        });
                    }
                }
            } catch (error) {
                console.error(`[UnifiedFormattingExtension] Error adding code block decorations:`, error);
            }
        }
    }

    /**
     * Detect headers in a line
     * @param line The line to check
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectHeaders(line: any, decorations: SortableDecoration[], isActive: boolean): void {
        try {
            const lineText = line.text;

            // Match headers: # to ###### followed by a space and text
            // More specific to avoid matching Python comments - requires a space after the #s
            const headerMatch = lineText.match(/^(#{1,6})\s+(.+)$/);

            if (headerMatch) {
                const hashMarker = headerMatch[1];
                const headerLevel = hashMarker.length; // # = 1, ## = 2, etc.
                const hashEnd = line.from + headerLevel;
                const headerText = headerMatch[2];
                const headerStart = hashEnd + 1; // +1 for the space after the #
                const headerEnd = line.from + headerMatch[0].length;
                
                console.log(`[UnifiedFormattingExtension] Detected header: level=${headerLevel}, text="${headerText}", from=${line.from}, to=${line.to}`);
                
                // Add line decoration for the entire header line first (lowest priority)
                decorations.push({
                    from: line.from,
                    to: line.from,
                    decoration: Decoration.line({
                        class: `cm-header-line cm-header-line-${headerLevel}`
                    }),
                    priority: 10, // Lower priority than the marker and content
                    source: this.config.id
                });

                // Add decoration for the hash symbols
                decorations.push({
                    from: line.from,
                    to: hashEnd,
                    decoration: Decoration.mark({
                        class: `cm-formatting cm-formatting-header cm-formatting-header-${headerLevel}`,
                        attributes: {
                            'data-header-hash': 'true',
                            'data-header-level': headerLevel.toString()
                        }
                    }),
                    priority: 20,
                    source: this.config.id
                });

                // Add decoration for the header text
                decorations.push({
                    from: headerStart,
                    to: headerEnd,
                    decoration: Decoration.mark({
                        class: `cm-header cm-header-${headerLevel}`,
                        attributes: { 'data-header-level': headerLevel.toString() }
                    }),
                    priority: 20,
                    source: this.config.id
                });
            }
        } catch (error) {
            console.error(`[UnifiedFormattingExtension] Error detecting headers:`, error);
        }
    }

    /**
     * Detect code fences in a line
     * @param line The line to check
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectCodeFences(line: any, decorations: SortableDecoration[], isActive: boolean): void {
        const lineText = line.text;

        // Match code fence markers: ``` optionally followed by a language identifier
        const codeFenceMatch = lineText.match(/^(\s*```([a-zA-Z0-9_+#-]*)\s*)$/);

        if (codeFenceMatch) {
            const fullMatch = codeFenceMatch[1];
            const language = codeFenceMatch[2] ? codeFenceMatch[2].trim() : '';
            
            console.log(`[UnifiedFormattingExtension] Detected code fence: language="${language}", line="${lineText}"`);

            // Add decoration for the entire code fence line
            decorations.push({
                from: line.from,
                to: line.from + fullMatch.length,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-code-block',
                    attributes: {
                        'data-formatting-type': 'code-fence',
                        'data-language': language || ''
                    }
                }),
                priority: 20,
                source: this.config.id
            });
            
            // Add line decoration for the code fence line
            decorations.push({
                from: line.from,
                to: line.from,
                decoration: Decoration.line({
                    class: 'cm-code-fence-line'
                }),
                priority: 10, // Lower priority than the marker
                source: this.config.id
            });
        }
    }

    /**
     * Detect list markers in a line
     * @param line The line to check
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectListMarkers(line: any, decorations: SortableDecoration[], isActive: boolean): void {
        const lineText = line.text;

        // Match unordered list markers: -, *, + followed by a space
        const unorderedListMatch = lineText.match(/^(\s*)([-*+])\s/);
        if (unorderedListMatch) {
            const indentation = unorderedListMatch[1];
            const marker = unorderedListMatch[2];
            const markerStart = line.from + indentation.length;
            const markerEnd = markerStart + marker.length;

            // Add decoration for the list marker
            decorations.push({
                from: markerStart,
                to: markerEnd,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-list',
                    attributes: { 'data-formatting-type': 'list' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Check if this is a task list item
            const taskMatch = lineText.match(/^\s*[-*+]\s+\[([ xX])\]/);
            if (taskMatch) {
                const checkboxStart = markerEnd + 1; // +1 for the space after the marker
                const checkboxEnd = checkboxStart + 3; // [x] is 3 chars
                const isChecked = taskMatch[1].toLowerCase() === 'x';

                // Add decoration for the task checkbox
                decorations.push({
                    from: checkboxStart,
                    to: checkboxEnd,
                    decoration: Decoration.mark({
                        class: `cm-formatting cm-formatting-task ${isChecked ? 'cm-formatting-task-checked' : ''}`,
                        attributes: {
                            'data-formatting-type': 'task',
                            'data-task-state': isChecked ? 'checked' : 'unchecked'
                        }
                    }),
                    priority: 20,
                    source: this.config.id
                });
            }

            return; // Don't process further if we found an unordered list marker
        }

        // Match ordered list markers: number followed by . and a space
        const orderedListMatch = lineText.match(/^(\s*)(\d+)\.(\s)/);
        if (orderedListMatch) {
            const indentation = orderedListMatch[1];
            const number = orderedListMatch[2];
            const markerStart = line.from + indentation.length;
            const markerEnd = markerStart + number.length + 1; // +1 for the dot

            // Add decoration for the list marker
            decorations.push({
                from: markerStart,
                to: markerEnd,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-list',
                    attributes: { 'data-formatting-type': 'list' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Check if this is a task list item
            const taskMatch = lineText.match(/^\s*\d+\.\s+\[([ xX])\]/);
            if (taskMatch) {
                const checkboxStart = markerEnd + 1; // +1 for the space after the marker
                const checkboxEnd = checkboxStart + 3; // [x] is 3 chars
                const isChecked = taskMatch[1].toLowerCase() === 'x';

                // Add decoration for the task checkbox
                decorations.push({
                    from: checkboxStart,
                    to: checkboxEnd,
                    decoration: Decoration.mark({
                        class: `cm-formatting cm-formatting-task ${isChecked ? 'cm-formatting-task-checked' : ''}`,
                        attributes: {
                            'data-formatting-type': 'task',
                            'data-task-state': isChecked ? 'checked' : 'unchecked'
                        }
                    }),
                    priority: 20,
                    source: this.config.id
                });
            }
        }
    }

    /**
     * Detect inline formatting in a line
     * @param line The line to check
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectInlineFormatting(line: any, decorations: SortableDecoration[], isActive: boolean): void {
        const lineText = line.text;

        // Detect bold formatting: ** or __
        this.detectBoldFormatting(line, lineText, decorations, isActive);

        // Detect italic formatting: * or _
        this.detectItalicFormatting(line, lineText, decorations, isActive);

        // Detect strikethrough formatting: ~~
        this.detectStrikethroughFormatting(line, lineText, decorations, isActive);

        // Detect inline code formatting: `
        this.detectInlineCodeFormatting(line, lineText, decorations, isActive);

        // Detect highlight formatting: ==
        this.detectHighlightFormatting(line, lineText, decorations, isActive);
    }

    /**
     * Detect bold formatting in a line
     * @param line The line to check
     * @param lineText The text of the line
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectBoldFormatting(line: any, lineText: string, decorations: SortableDecoration[], isActive: boolean): void {
        // Match bold formatting: ** or __
        const boldRegex = /\*\*(.*?)\*\*|__(.*?)__/g;
        let match;

        while ((match = boldRegex.exec(lineText)) !== null) {
            const fullMatch = match[0];
            const isStar = fullMatch.startsWith('**');

            // Add decoration for opening marker
            decorations.push({
                from: line.from + match.index,
                to: line.from + match.index + 2, // ** or __ is 2 chars
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-strong',
                    attributes: { 'data-formatting-type': 'bold' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for content
            decorations.push({
                from: line.from + match.index + 2,
                to: line.from + match.index + fullMatch.length - 2,
                decoration: Decoration.mark({
                    class: 'cm-strong',
                    attributes: { 'data-formatting-type': 'bold-content' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing marker
            decorations.push({
                from: line.from + match.index + fullMatch.length - 2,
                to: line.from + match.index + fullMatch.length,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-strong',
                    attributes: { 'data-formatting-type': 'bold' }
                }),
                priority: 20,
                source: this.config.id
            });
        }
    }

    /**
     * Detect italic formatting in a line
     * @param line The line to check
     * @param lineText The text of the line
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectItalicFormatting(line: any, lineText: string, decorations: SortableDecoration[], isActive: boolean): void {
        // Match italic formatting: * or _
        // Avoid matching ** or __ which are for bold
        const italicRegex = /(?<!\*)\*(?!\*)(.*?)\*(?!\*)|(?<!_)_(?!_)(.*?)_(?!_)/g;
        let match;

        while ((match = italicRegex.exec(lineText)) !== null) {
            const fullMatch = match[0];
            const isStar = fullMatch.startsWith('*');

            // Add decoration for opening marker
            decorations.push({
                from: line.from + match.index,
                to: line.from + match.index + 1, // * or _ is 1 char
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-em',
                    attributes: { 'data-formatting-type': 'italic' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for content
            decorations.push({
                from: line.from + match.index + 1,
                to: line.from + match.index + fullMatch.length - 1,
                decoration: Decoration.mark({
                    class: 'cm-em',
                    attributes: { 'data-formatting-type': 'italic-content' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing marker
            decorations.push({
                from: line.from + match.index + fullMatch.length - 1,
                to: line.from + match.index + fullMatch.length,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-em',
                    attributes: { 'data-formatting-type': 'italic' }
                }),
                priority: 20,
                source: this.config.id
            });
        }
    }

    /**
     * Detect strikethrough formatting in a line
     * @param line The line to check
     * @param lineText The text of the line
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectStrikethroughFormatting(line: any, lineText: string, decorations: SortableDecoration[], isActive: boolean): void {
        // Match strikethrough formatting: ~~
        const strikethroughRegex = /~~(.*?)~~/g;
        let match;

        while ((match = strikethroughRegex.exec(lineText)) !== null) {
            const fullMatch = match[0];

            // Add decoration for opening marker
            decorations.push({
                from: line.from + match.index,
                to: line.from + match.index + 2, // ~~ is 2 chars
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-strikethrough',
                    attributes: { 'data-formatting-type': 'strikethrough' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for content
            decorations.push({
                from: line.from + match.index + 2,
                to: line.from + match.index + fullMatch.length - 2,
                decoration: Decoration.mark({
                    class: 'cm-strikethrough',
                    attributes: { 'data-formatting-type': 'strikethrough-content' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing marker
            decorations.push({
                from: line.from + match.index + fullMatch.length - 2,
                to: line.from + match.index + fullMatch.length,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-strikethrough',
                    attributes: { 'data-formatting-type': 'strikethrough' }
                }),
                priority: 20,
                source: this.config.id
            });
        }
    }

    /**
     * Detect inline code formatting in a line
     * @param line The line to check
     * @param lineText The text of the line
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectInlineCodeFormatting(line: any, lineText: string, decorations: SortableDecoration[], isActive: boolean): void {
        // Match inline code formatting: `
        const inlineCodeRegex = /`([^`]+)`/g;
        let match;

        while ((match = inlineCodeRegex.exec(lineText)) !== null) {
            const fullMatch = match[0];

            // Add decoration for opening marker
            decorations.push({
                from: line.from + match.index,
                to: line.from + match.index + 1, // ` is 1 char
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-code',
                    attributes: { 'data-formatting-type': 'inline-code' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for content
            decorations.push({
                from: line.from + match.index + 1,
                to: line.from + match.index + fullMatch.length - 1,
                decoration: Decoration.mark({
                    class: 'cm-inline-code',
                    attributes: { 'data-formatting-type': 'inline-code-content' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing marker
            decorations.push({
                from: line.from + match.index + fullMatch.length - 1,
                to: line.from + match.index + fullMatch.length,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-code',
                    attributes: { 'data-formatting-type': 'inline-code' }
                }),
                priority: 20,
                source: this.config.id
            });
        }
    }

    /**
     * Detect highlight formatting in a line
     * @param line The line to check
     * @param lineText The text of the line
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectHighlightFormatting(line: any, lineText: string, decorations: SortableDecoration[], isActive: boolean): void {
        // Match highlight formatting: ==
        const highlightRegex = /==(.*?)==/g;
        let match;

        while ((match = highlightRegex.exec(lineText)) !== null) {
            const fullMatch = match[0];

            // Add decoration for opening marker
            decorations.push({
                from: line.from + match.index,
                to: line.from + match.index + 2, // == is 2 chars
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-highlight',
                    attributes: { 'data-formatting-type': 'highlight' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for content
            decorations.push({
                from: line.from + match.index + 2,
                to: line.from + match.index + fullMatch.length - 2,
                decoration: Decoration.mark({
                    class: 'cm-highlight',
                    attributes: { 'data-formatting-type': 'highlight-content' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing marker
            decorations.push({
                from: line.from + match.index + fullMatch.length - 2,
                to: line.from + match.index + fullMatch.length,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-highlight',
                    attributes: { 'data-formatting-type': 'highlight' }
                }),
                priority: 20,
                source: this.config.id
            });
        }
    }

    /**
     * Detect links and images in a line
     * @param line The line to check
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectLinksAndImages(line: any, decorations: SortableDecoration[], isActive: boolean): void {
        const lineText = line.text;

        // Detect links: [text](url)
        this.detectLinks(line, lineText, decorations, isActive);

        // Detect images: ![alt](url)
        this.detectImages(line, lineText, decorations, isActive);
    }

    /**
     * Detect links in a line
     * @param line The line to check
     * @param lineText The text of the line
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectLinks(line: any, lineText: string, decorations: SortableDecoration[], isActive: boolean): void {
        // Match links: [text](url)
        const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
        let match;

        while ((match = linkRegex.exec(lineText)) !== null) {
            const fullMatch = match[0];
            const text = match[1];
            const url = match[2];

            // Add decoration for opening [
            decorations.push({
                from: line.from + match.index,
                to: line.from + match.index + 1,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-link',
                    attributes: { 'data-formatting-type': 'link' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for link text
            decorations.push({
                from: line.from + match.index + 1,
                to: line.from + match.index + 1 + text.length,
                decoration: Decoration.mark({
                    class: 'cm-link-text',
                    attributes: { 'data-formatting-type': 'link-text' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing ]
            const closingBracketPos = match.index + text.length + 1;
            decorations.push({
                from: line.from + closingBracketPos,
                to: line.from + closingBracketPos + 1,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-link',
                    attributes: { 'data-formatting-type': 'link' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for opening (
            decorations.push({
                from: line.from + closingBracketPos + 1,
                to: line.from + closingBracketPos + 2,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-link',
                    attributes: { 'data-formatting-type': 'link' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for URL
            decorations.push({
                from: line.from + closingBracketPos + 2,
                to: line.from + match.index + fullMatch.length - 1,
                decoration: Decoration.mark({
                    class: 'cm-link-url',
                    attributes: {
                        'data-formatting-type': 'link-url',
                        'data-url': url
                    }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing )
            decorations.push({
                from: line.from + match.index + fullMatch.length - 1,
                to: line.from + match.index + fullMatch.length,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-link',
                    attributes: { 'data-formatting-type': 'link' }
                }),
                priority: 20,
                source: this.config.id
            });
        }
    }

    /**
     * Detect images in a line
     * @param line The line to check
     * @param lineText The text of the line
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectImages(line: any, lineText: string, decorations: SortableDecoration[], isActive: boolean): void {
        // Match images: ![alt](url)
        const imageRegex = /!\[([^\]]+)\]\(([^)]+)\)/g;
        let match;

        while ((match = imageRegex.exec(lineText)) !== null) {
            const fullMatch = match[0];
            const alt = match[1];
            const url = match[2];

            // Add decoration for opening ![
            decorations.push({
                from: line.from + match.index,
                to: line.from + match.index + 2,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-image',
                    attributes: { 'data-formatting-type': 'image' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for alt text
            decorations.push({
                from: line.from + match.index + 2,
                to: line.from + match.index + 2 + alt.length,
                decoration: Decoration.mark({
                    class: 'cm-image-alt-text',
                    attributes: { 'data-formatting-type': 'image-alt-text' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing ]
            const closingBracketPos = match.index + 2 + alt.length;
            decorations.push({
                from: line.from + closingBracketPos,
                to: line.from + closingBracketPos + 1,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-image',
                    attributes: { 'data-formatting-type': 'image' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for opening (
            decorations.push({
                from: line.from + closingBracketPos + 1,
                to: line.from + closingBracketPos + 2,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-image',
                    attributes: { 'data-formatting-type': 'image' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for URL
            decorations.push({
                from: line.from + closingBracketPos + 2,
                to: line.from + match.index + fullMatch.length - 1,
                decoration: Decoration.mark({
                    class: 'cm-image-url',
                    attributes: {
                        'data-formatting-type': 'image-url',
                        'data-url': url
                    }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for closing )
            decorations.push({
                from: line.from + match.index + fullMatch.length - 1,
                to: line.from + match.index + fullMatch.length,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-image',
                    attributes: { 'data-formatting-type': 'image' }
                }),
                priority: 20,
                source: this.config.id
            });
        }
    }

    /**
     * Detect blockquotes in a line
     * @param line The line to check
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectBlockquotes(line: any, decorations: SortableDecoration[], isActive: boolean): void {
        const lineText = line.text;

        // Match blockquotes: > followed by optional space and text
        const blockquoteMatch = lineText.match(/^(\s*)(>\s?)(.*)$/);

        if (blockquoteMatch) {
            const indentation = blockquoteMatch[1];
            const marker = blockquoteMatch[2];
            const markerStart = line.from + indentation.length;
            const markerEnd = markerStart + marker.length;

            // Add decoration for the blockquote marker
            decorations.push({
                from: markerStart,
                to: markerEnd,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-quote',
                    attributes: { 'data-formatting-type': 'blockquote' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add decoration for the blockquote content
            decorations.push({
                from: markerEnd,
                to: line.to,
                decoration: Decoration.mark({
                    class: 'cm-quote',
                    attributes: { 'data-formatting-type': 'blockquote-content' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add line decoration for the entire blockquote line
            decorations.push({
                from: line.from,
                to: line.from,
                decoration: Decoration.line({
                    class: 'cm-blockquote-line'
                }),
                priority: 10, // Lower priority than the marker and content
                source: this.config.id
            });
        }
    }

    /**
     * Detect horizontal rules in a line
     * @param line The line to check
     * @param decorations The array of decorations to add to
     * @param isActive Whether the line is active
     */
    private detectHorizontalRules(line: any, decorations: SortableDecoration[], isActive: boolean): void {
        const lineText = line.text;

        // Match horizontal rules: ---, ***, or ___ (at least 3 characters)
        const horizontalRuleMatch = lineText.match(/^\s*([-*_])\1{2,}\s*$/);

        if (horizontalRuleMatch) {
            // Add decoration for the entire horizontal rule
            decorations.push({
                from: line.from,
                to: line.to,
                decoration: Decoration.mark({
                    class: 'cm-formatting cm-formatting-hr',
                    attributes: { 'data-formatting-type': 'horizontal-rule' }
                }),
                priority: 20,
                source: this.config.id
            });

            // Add line decoration for the horizontal rule
            decorations.push({
                from: line.from,
                to: line.from,
                decoration: Decoration.line({
                    class: 'cm-horizontal-rule-line'
                }),
                priority: 10, // Lower priority than the marker
                source: this.config.id
            });
        }
    }

    /**
     * Create the CodeMirror extensions for this extension
     * @returns An array of CodeMirror extensions
     */
    createExtensions() {
        console.log('[UnifiedFormattingExtension] Creating extensions');
        
        // Log the current state of the decoration manager
        if (this.decorationManager) {
            console.log('[UnifiedFormattingExtension] Decoration manager is available');
        } else {
            console.warn('[UnifiedFormattingExtension] No decoration manager available');
        }
        
        return [
            // Add the view plugin for decorations
            this.createViewPlugin(),

            // Add the theme for styling the formatting
            EditorView.baseTheme({
                // Base formatting - hidden by default
                '.cm-formatting': {
                    display: 'none', // Hide formatting by default
                    color: 'var(--text-faint)',
                    opacity: 0.7
                },
                
                // Debug mode - always show formatting
                '.debug-formatting .cm-formatting': {
                    display: 'inline !important',
                    color: 'red !important',
                    opacity: 1
                },
                
                // Debug mode - highlight headers
                '.debug-formatting .cm-header': {
                    backgroundColor: 'rgba(255, 0, 0, 0.1) !important'
                },
                
                // Debug mode - highlight code blocks
                '.debug-formatting .cm-line.cm-code-block-start, .debug-formatting .cm-line.cm-code-block-content, .debug-formatting .cm-line.cm-code-block-end': {
                    backgroundColor: 'rgba(0, 255, 0, 0.1) !important'
                },
                

                // Show on active line
                '.cm-line.cm-activeLine .cm-formatting': {
                    display: 'inline',
                    opacity: 0.9 // Increase opacity on active line
                },
                
                // Code block formatting
                '.cm-formatting-code-block-start, .cm-formatting-code-block-end, .cm-formatting-code-block': {
                    color: 'var(--text-accent)',
                    opacity: 0.8,
                    fontFamily: 'var(--font-monospace)'
                },
                
                // Header formatting
                '.cm-formatting-header, .cm-formatting-header-1, .cm-formatting-header-2, .cm-formatting-header-3, .cm-formatting-header-4, .cm-formatting-header-5, .cm-formatting-header-6': {
                    color: 'var(--text-accent)',
                    opacity: 0.8,
                    fontWeight: 'bold'
                },

                // Bold styling
                '.cm-strong': {
                    fontWeight: 'bold'
                },

                // Italic styling
                '.cm-em': {
                    fontStyle: 'italic'
                },

                // Strikethrough styling
                '.cm-strikethrough': {
                    textDecoration: 'line-through'
                },

                // Inline code styling
                '.cm-inline-code': {
                    fontFamily: 'var(--font-monospace)',
                    backgroundColor: 'var(--code-background)',
                    padding: '0.1em 0.2em',
                    borderRadius: '0.2em',
                    fontSize: '0.9em'
                },

                // Highlight styling
                '.cm-highlight': {
                    backgroundColor: 'var(--text-highlight-bg)',
                    color: 'var(--text-normal)'
                },

                // Link styling
                '.cm-link-text': {
                    color: 'var(--text-accent)',
                    textDecoration: 'underline'
                },

                '.cm-link-url': {
                    color: 'var(--text-accent)',
                    opacity: 0.8
                },

                // Image styling
                '.cm-image-alt-text': {
                    color: 'var(--text-accent)',
                    fontStyle: 'italic'
                },

                '.cm-image-url': {
                    color: 'var(--text-accent)',
                    opacity: 0.8
                },

                // Blockquote styling
                '.cm-blockquote-line': {
                    borderLeft: '4px solid var(--blockquote-border)',
                    paddingLeft: '0.5em',
                    color: 'var(--text-normal)',
                    backgroundColor: 'var(--blockquote-background)'
                },

                '.cm-formatting-quote': {
                    color: 'var(--text-accent)',
                    fontWeight: 'bold'
                },

                '.cm-quote': {
                    color: 'var(--text-normal)',
                    fontStyle: 'italic'
                },

                // Horizontal rule styling
                '.cm-horizontal-rule-line': {
                    textAlign: 'center'
                },

                '.cm-formatting-hr': {
                    color: 'var(--text-faint)',
                    textAlign: 'center'
                },

                // Header styling
                '.cm-header': {
                    fontFamily: 'var(--font-heading, var(--font-text))',
                    fontWeight: 'bold',
                    lineHeight: '1.3',
                    letterSpacing: '-0.01em',
                    color: 'var(--text-heading, var(--text-normal))'
                },

                // Header levels
                '.cm-header-1': {
                    fontSize: '2.2em',
                    fontWeight: '800',
                    color: 'var(--text-heading-h1, var(--interactive-accent, #5e81ac))',
                    borderBottom: '1px solid var(--background-modifier-border)',
                    paddingBottom: '0.3em',
                    marginTop: '0.5em',
                    marginBottom: '0.8em',
                    letterSpacing: '-0.02em'
                },
                '.cm-header-2': {
                    fontSize: '1.8em',
                    color: 'var(--text-heading-h2, var(--text-normal))',
                    borderBottom: '1px solid var(--background-modifier-border)',
                    paddingBottom: '0.2em',
                    marginTop: '1.2em',
                    marginBottom: '0.7em'
                },
                '.cm-header-3': {
                    fontSize: '1.5em',
                    color: 'var(--text-heading-h3, var(--text-normal))',
                    marginTop: '1.1em',
                    marginBottom: '0.6em'
                },
                '.cm-header-4': {
                    fontSize: '1.3em',
                    color: 'var(--text-heading-h4, var(--text-normal))',
                    marginTop: '1em',
                    marginBottom: '0.5em'
                },
                '.cm-header-5': {
                    fontSize: '1.15em',
                    color: 'var(--text-heading-h5, var(--text-muted))',
                    marginTop: '0.9em',
                    marginBottom: '0.4em'
                },
                '.cm-header-6': {
                    fontSize: '1em',
                    color: 'var(--text-heading-h6, var(--text-muted))',
                    fontStyle: 'italic',
                    marginTop: '0.8em',
                    marginBottom: '0.3em'
                },

                // Code blocks
                '.cm-line.cm-code-block-start': {
                    fontFamily: 'var(--font-monospace)',
                    backgroundColor: 'var(--code-background)',
                    borderTopLeftRadius: '6px',
                    borderTopRightRadius: '6px',
                    padding: '8px 16px',
                    marginTop: '16px'
                },

                '.cm-line.cm-code-block-content': {
                    fontFamily: 'var(--font-monospace)',
                    backgroundColor: 'var(--code-background)',
                    padding: '0 16px',
                    whiteSpace: 'pre-wrap'
                },

                '.cm-line.cm-code-block-end': {
                    fontFamily: 'var(--font-monospace)',
                    backgroundColor: 'var(--code-background)',
                    borderBottomLeftRadius: '6px',
                    borderBottomRightRadius: '6px',
                    padding: '0 16px 8px',
                    marginBottom: '16px'
                },

                // Language indicator
                '.code-block-language': {
                    position: 'absolute',
                    top: '8px',
                    right: '44px',
                    fontSize: 'var(--font-size-smallest, 0.75em)',
                    padding: '2px 8px',
                    borderRadius: 'var(--border-radius, 4px)',
                    backgroundColor: 'var(--interactive-accent-hover, rgba(94, 129, 172, 0.8))',
                    color: 'var(--text-on-accent, white)',
                    fontWeight: 'bold',
                    textTransform: 'uppercase',
                    letterSpacing: '0.05em',
                    opacity: '0.9',
                    transition: 'opacity 0.2s ease',
                    border: '1px solid var(--background-modifier-border)',
                    zIndex: '10'
                },

                // Copy button
                '.code-block-copy-button': {
                    position: 'absolute',
                    top: '8px',
                    right: '8px',
                    width: '28px',
                    height: '28px',
                    padding: '4px',
                    backgroundColor: 'var(--background-secondary)',
                    border: '1px solid var(--background-modifier-border)',
                    borderRadius: 'var(--border-radius, 4px)',
                    color: 'var(--text-muted)',
                    cursor: 'pointer',
                    opacity: '0.8',
                    transition: 'all 0.2s ease',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: '10'
                },

                '.code-block-copy-button:hover': {
                    opacity: '1',
                    backgroundColor: 'var(--background-modifier-hover)'
                },

                '.code-block-copy-button.copied': {
                    backgroundColor: 'var(--interactive-accent)',
                    color: 'var(--text-on-accent)'
                }
            })
        ];
    }
}
