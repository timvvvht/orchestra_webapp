import { useState, useCallback, useEffect } from 'react';
import type { OrchestACSClient, SessionSummary, SessionDetails } from '@/services/acs';
import { useMessagesStore } from '@/store/messagesStore';

export interface UseACSChatSessionsOptions {
  autoLoad?: boolean;
  userId?: string;
}

export interface UseACSChatSessionsReturn {
  // State
  sessions: SessionSummary[];
  currentSessionId: string | undefined;
  currentSession: SessionDetails | undefined;
  isLoading: boolean;
  error: string | null;

  // Actions
  loadSessions: () => Promise<void>;
  createSession: (name?: string, agentConfigId?: string, agentCwd?: string) => Promise<string>;
  switchToSession: (sessionId: string) => Promise<void>;
  deleteSession: (sessionId: string) => Promise<void>;
  renameSession: (sessionId: string, newName: string) => Promise<void>;
  loadSessionDetails: (sessionId: string) => Promise<void>;
  setCurrentSessionId: (sessionId: string | undefined) => void;
  clearError: () => void;
}

/**
 * Hook for managing ACS chat sessions
 * Handles session CRUD operations and current session state
 */
export const useACSChatSessions = (
  acsClient: OrchestACSClient,
  options: UseACSChatSessionsOptions = {}
): UseACSChatSessionsReturn => {
  const { autoLoad = true, userId } = options;

  // State
  const [sessions, setSessions] = useState<SessionSummary[]>([]);
  const [currentSessionId, setCurrentSessionIdState] = useState<string | undefined>();
  const [currentSession, setCurrentSession] = useState<SessionDetails | undefined>();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Wrapped setCurrentSessionId with debug logging
  const setCurrentSessionId = useCallback((sessionId: string | undefined) => {
    console.log('🔄 [SESSIONS] setCurrentSessionId called with:', sessionId);
    console.log('🔄 [SESSIONS] Previous currentSessionId was:', currentSessionId);
    setCurrentSessionIdState(sessionId);
    console.log('🔄 [SESSIONS] setCurrentSessionIdState called, new state should be:', sessionId);
  }, [currentSessionId]);
  
  // Messages store actions
  const setMessages = useMessagesStore(state => state.setMessages);
  const clearMessages = useMessagesStore(state => state.clearMessages);

  // Load sessions
  const loadSessions = useCallback(async () => {
    console.log('📋 [G4] loadSessions() START');
    try {
      setIsLoading(true);
      setError(null);
      
      console.log('📋 [G4] Calling acsClient.sessions.listSessions...');
      const response = await acsClient.sessions.listSessions({
        limit: 100,
        includeMessageCount: false
      });
      
      console.log('📋 [G4] Sessions response:', response.data.sessions?.length || 0, 'sessions');
      setSessions(response.data.sessions);
      console.log('✅ [G4] loadSessions() SUCCESS');
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load sessions';
      console.error('❌ [G4] loadSessions() FAILED:', err);
      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [acsClient]);

  // Create session
  const createSession = useCallback(async (name?: string, agentConfigId?: string, agentCwd?: string) => {
    try {
      setIsLoading(true);
      setError(null);
      

      
      if (!userId) {
        throw new Error('User not authenticated - userId is missing');
      }

      // Use the current Orchestra project directory as default
      const defaultCwd = agentCwd || '/Users/tim/Code/orchestra';
      
      const response = await acsClient.sessions.createDefaultSession(
        name, 
        agentConfigId || 'general',
        { agentCwd: defaultCwd }
      );
      const sessionId = response.data?.data?.session_id || response.data?.data?.id;
      
      if (sessionId) {
        await loadSessions(); // Refresh sessions list
        return sessionId;
      }
      
      throw new Error(`Failed to create session - no session_id in response: ${JSON.stringify(response.data)}`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create session';

      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [acsClient, userId, loadSessions]);

  // Load session details
  const loadSessionDetails = useCallback(async (sessionId: string) => {
    console.log('📄 [SES] loadSessionDetails START:', sessionId);
    console.log('📄 [SES] ACS Client available:', !!acsClient);
    console.log('📄 [SES] Current loading state:', isLoading);
    
    // Guard against temp session IDs
    if (sessionId.startsWith('temp-')) {
      console.log('⏸️ [SES] Skipping temp session:', sessionId);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);
      
      console.log('📄 [SES] Fetching session details...');
      const response = await acsClient.sessions.getSession(sessionId, {
        includeMessages: true
      });

      console.log('📄 [SES] Session details response:', {
        sessionId: response.data.id,
        name: response.data.name,
        messageCount: response.data.messages?.length || 0
      });

      setCurrentSession(response.data);
      
      // Set messages in the messages store for timeline to work
      if (response.data.messages && response.data.messages.length > 0) {
        console.log('📄 [SES] Setting', response.data.messages.length, 'messages in store');
        setMessages(draft => {
          draft.length = 0; // Clear existing messages
          draft.push(...response.data.messages); // Add new messages
        });
      } else {
        console.log('📄 [SES] No messages, clearing store');
        clearMessages();
      }
      
      console.log('✅ [SES] loadSessionDetails SUCCESS');
    } catch (err) {
      console.error('❌ [SES] loadSessionDetails FAILED:', err);
      setError('Failed to load session details');
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [acsClient, setMessages, clearMessages]);

  // Switch to session
  const switchToSession = useCallback(async (sessionId: string) => {
    console.log('🔄 [SES] switchToSession:', sessionId);
    try {
      setCurrentSessionId(sessionId);
      await loadSessionDetails(sessionId);
    } catch (err) {
      console.error('❌ [SES] switchToSession FAILED:', err);
      setError('Failed to switch to session');
      throw err;
    }
  }, [setCurrentSessionId, loadSessionDetails]);

  // Delete session
  const deleteSession = useCallback(async (sessionId: string) => {
    try {
      setIsLoading(true);
      setError(null);
      
      await acsClient.sessions.deleteSession(sessionId);
      await loadSessions();

      if (sessionId === currentSessionId) {
        setCurrentSessionId(undefined);
        setCurrentSession(undefined);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to delete session';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [acsClient, currentSessionId, loadSessions]);

  // Rename session
  const renameSession = useCallback(async (sessionId: string, newName: string) => {
    try {
      setIsLoading(true);
      setError(null);
      
      await acsClient.sessions.renameSession(sessionId, newName);
      await loadSessions();

      if (sessionId === currentSessionId) {
        await loadSessionDetails(sessionId);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to rename session';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [acsClient, currentSessionId, loadSessions]);

  // Load session details
  const loadSessionDetails = useCallback(async (sessionId: string) => {
    console.log('📄 [SES] loadSessionDetails START:', sessionId);
    console.log('📄 [SES] ACS Client available:', !!acsClient);
    console.log('📄 [SES] Current loading state:', isLoading);
    
    // Guard against temp session IDs
    if (sessionId.startsWith('temp-')) {
      console.log('⏸️ [SES] Skipping temp session:', sessionId);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);
      
      console.log('📄 [SES] Fetching session details...');
      const response = await acsClient.sessions.getSession(sessionId, {
        includeMessages: true
      });

      console.log('📄 [SES] Session details response:', {
        sessionId: response.data.id,
        name: response.data.name,
        messageCount: response.data.messages?.length || 0
      });





      setCurrentSession(response.data);
      
      // Set messages in the messages store for timeline to work
      if (response.data.messages && response.data.messages.length > 0) {
        console.log('📄 [SES] Setting', response.data.messages.length, 'messages in store');
        setMessages(draft => {
          draft.length = 0; // Clear existing messages
          draft.push(...response.data.messages); // Add new messages
        });
      } else {
        console.log('📄 [SES] No messages, clearing store');
        clearMessages();
      }
      
      console.log('✅ [SES] loadSessionDetails SUCCESS');
    } catch (err) {
      console.error('❌ [SES] loadSessionDetails FAILED:', err);
      setError('Failed to load session details');
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [acsClient, setMessages, clearMessages]);

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Debug: Log when currentSessionId changes
  useEffect(() => {
    console.log('🔄 [SESSIONS] currentSessionId state changed to:', currentSessionId);
  }, [currentSessionId]);

  // Auto-load sessions on mount
  useEffect(() => {
    if (autoLoad && acsClient) {
      loadSessions();
    }
  }, [autoLoad, acsClient, loadSessions]);

  return {
    // State
    sessions,
    currentSessionId, // This is the state variable
    currentSession,
    isLoading,
    error,

    // Actions
    loadSessions,
    createSession,
    switchToSession,
    deleteSession,
    renameSession,
    loadSessionDetails,
    setCurrentSessionId, // This is our wrapped function with debug logging
    clearError
  };
};